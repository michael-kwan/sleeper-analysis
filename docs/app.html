<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sleeper Analytics - League Report</title>

    <!-- Plotly -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: white;
        }

        .header p {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.9);
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            margin: 20px 0;
        }

        .loading h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #667eea;
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
            padding-bottom: 10px;
        }

        .section h3 {
            font-size: 1.3em;
            margin: 25px 0 15px 0;
            color: #a78bfa;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        th {
            background: rgba(102, 126, 234, 0.2);
            font-weight: 600;
            color: #667eea;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 0.5px;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .positive {
            color: #4ade80;
        }

        .negative {
            color: #f87171;
        }

        .highlight {
            background: rgba(102, 126, 234, 0.1);
            font-weight: bold;
        }

        .error {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid #f87171;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .error h2 {
            color: #f87171;
            margin-bottom: 10px;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            text-decoration: none;
            transition: all 0.2s ease;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .toggle-container {
            margin: 20px 0;
        }

        .toggle-container label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.95em;
        }

        .toggle-container input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Home</a>

        <div class="header">
            <h1 id="league-name">Loading...</h1>
            <p id="league-info">Fetching league information...</p>
        </div>

        <div class="loading" id="loading">
            <h2>üèà Analyzing Your League...</h2>
            <div class="spinner"></div>
            <p id="status">Fetching data from API...</p>
        </div>

        <div id="content" style="display: none;">
            <!-- Content will be generated by JavaScript -->
        </div>

        <div id="error" class="error" style="display: none;">
            <h2>‚ö†Ô∏è Error</h2>
            <p id="error-message"></p>
        </div>
    </div>

    <script>
        const API_BASE = 'https://sleeper-analysis-production.up.railway.app';

        // Get league ID from URL
        const params = new URLSearchParams(window.location.search);
        const leagueId = params.get('league_id');

        if (!leagueId) {
            document.getElementById('error').style.display = 'block';
            document.getElementById('error-message').textContent = 'No league ID provided. Please go back and enter a league ID.';
            document.getElementById('loading').style.display = 'none';
        } else {
            generateReport(leagueId);
        }

        async function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        async function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        async function fetchAPI(endpoint) {
            try {
                const response = await fetch(`${API_BASE}${endpoint}`);
                if (!response.ok) {
                    const errorText = await response.text().catch(() => response.statusText);
                    throw new Error(`${endpoint} failed (${response.status}): ${errorText || response.statusText}`);
                }
                return response.json();
            } catch (error) {
                console.error(`Error fetching ${endpoint}:`, error);
                throw new Error(`${endpoint}: ${error.message}`);
            }
        }

        function toggleQBs() {
            const excludeQBs = document.getElementById('excludeQBs').checked;

            // Toggle table bodies
            document.getElementById('bestPicksAll').style.display = excludeQBs ? 'none' : '';
            document.getElementById('bestPicksNoQB').style.display = excludeQBs ? '' : 'none';
            document.getElementById('worstPicksAll').style.display = excludeQBs ? 'none' : '';
            document.getElementById('worstPicksNoQB').style.display = excludeQBs ? '' : 'none';
        }

        async function generateReport(leagueId) {
            try {
                await updateStatus('üìä Fetching league information...');

                // Fetch league info from Sleeper API directly
                const league = await fetch(`https://api.sleeper.app/v1/league/${leagueId}`).then(r => r.json());

                // Update header
                document.getElementById('league-name').textContent = league.name;
                document.getElementById('league-info').textContent = `Season ${league.season} ‚Ä¢ ${league.total_rosters} Teams`;

                // Fetch all data concurrently
                await updateStatus('üîÑ Fetching all analytics data...');

                let standings, awards, benchwarmers, luck, faab, rosterConstruction, draft, lopsidedTrades, transactionActivity;

                try {
                    await updateStatus('üìä Fetching standings...');
                    standings = await fetchAPI(`/api/matchups/${leagueId}/standings?weeks=14`);

                    await updateStatus('üéñÔ∏è Fetching awards...');
                    awards = await fetchAPI(`/api/awards/${leagueId}/season?weeks=14`);

                    await updateStatus('üí∫ Fetching benchwarmer analysis...');
                    benchwarmers = await fetchAPI(`/api/benchwarmer/${leagueId}/league?weeks=14`);

                    await updateStatus('üçÄ Fetching luck analysis...');
                    luck = await fetchAPI(`/api/luck/${leagueId}/league?weeks=14`);

                    await updateStatus('üí∞ Fetching FAAB analysis...');
                    faab = await fetchAPI(`/api/faab/${leagueId}/report?weeks=14`);

                    await updateStatus('üèóÔ∏è Fetching roster construction...');
                    rosterConstruction = await fetchAPI(`/api/roster-construction/${leagueId}/league?weeks=14`);

                    await updateStatus('üéØ Fetching draft analysis...');
                    draft = await fetchAPI(`/api/draft/${leagueId}/analysis?weeks=14`);

                    await updateStatus('ü§ù Fetching trade analysis...');
                    lopsidedTrades = await fetchAPI(`/api/trades/${leagueId}/lopsided?weeks=14`);

                    await updateStatus('üìã Fetching transaction activity...');
                    transactionActivity = await fetchAPI(`/api/transactions/${leagueId}/activity?weeks=14`);
                } catch (error) {
                    throw error; // Re-throw with detailed endpoint info
                }

                // Combine trades data
                const trades = {
                    most_lopsided_trades: lopsidedTrades.trades || [],
                    transaction_activity: transactionActivity.team_activity || []
                };

                await updateStatus('üìù Generating comprehensive report...');

                // Build complete HTML content
                let html = buildStandingsSection(standings);
                html += buildAwardsSection(awards);
                html += buildBenchwarmerSection(benchwarmers);
                html += buildLuckSection(luck);
                html += buildFAABSection(faab);
                html += buildRosterConstructionSection(rosterConstruction);
                html += buildDraftSection(draft);
                html += buildTradesSection(trades);

                // Set content and hide loading
                document.getElementById('content').innerHTML = html;
                document.getElementById('content').style.display = 'block';
                document.getElementById('loading').style.display = 'none';

                await updateStatus('üìä Complete!');

            } catch (error) {
                console.error('Error generating report:', error);
                await showError(`Failed to generate report: ${error.message}. Make sure the league ID is valid and the API is running.`);
            }
        }

        function buildStandingsSection(standings) {
            let html = '<div class="section"><h2>üèÜ League Standings</h2><table>';
            html += '<thead><tr><th>Rank</th><th>Team</th><th>Record</th><th>PF</th><th>PA</th><th>Diff</th></tr></thead><tbody>';
            standings.forEach((team, idx) => {
                const diff = team.points_for - team.points_against;
                const diffClass = diff > 0 ? 'positive' : 'negative';
                html += `<tr>
                    <td>${idx + 1}</td>
                    <td>${team.team_name}</td>
                    <td>${team.wins}-${team.losses}</td>
                    <td>${team.points_for.toFixed(2)}</td>
                    <td>${team.points_against.toFixed(2)}</td>
                    <td class="${diffClass}">${diff > 0 ? '+' : ''}${diff.toFixed(2)}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            return html;
        }

        function buildAwardsSection(awards) {
            let html = '<div class="section"><h2>üéñÔ∏è Weekly Awards (High/Low Scorers)</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">$5/week payout for high scorer, $5/week penalty for low scorer</p>';
            html += '<table><thead><tr><th>Week</th><th>High Scorer</th><th>Score</th><th>Low Scorer</th><th>Score</th></tr></thead><tbody>';
            awards.weekly_awards.forEach(week => {
                html += `<tr>
                    <td>${week.week}</td>
                    <td>${week.high_scorer}</td>
                    <td class="positive">${week.high_score.toFixed(2)}</td>
                    <td>${week.low_scorer}</td>
                    <td class="negative">${week.low_score.toFixed(2)}</td>
                </tr>`;
            });
            html += '</tbody></table>';

            // Convert API response dicts to payout summary array
            const payoutSummary = [];
            for (const [teamName, netPayout] of Object.entries(awards.payout_by_team)) {
                payoutSummary.push({
                    team_name: teamName,
                    high_scorer_count: awards.high_score_leaders[teamName] || 0,
                    low_scorer_count: awards.low_score_leaders[teamName] || 0,
                    net_payout: netPayout
                });
            }
            // Sort by net payout descending
            payoutSummary.sort((a, b) => b.net_payout - a.net_payout);

            // Payout summary
            html += '<h3>Season Payout Summary</h3><table>';
            html += '<thead><tr><th>Team</th><th>High Scorer Count</th><th>Low Scorer Count</th><th>Net Payout</th></tr></thead><tbody>';
            payoutSummary.forEach(team => {
                const netClass = team.net_payout > 0 ? 'positive' : (team.net_payout < 0 ? 'negative' : '');
                html += `<tr>
                    <td>${team.team_name}</td>
                    <td class="positive">${team.high_scorer_count}</td>
                    <td class="negative">${team.low_scorer_count}</td>
                    <td class="${netClass}">${team.net_payout > 0 ? '+' : ''}$${team.net_payout}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            return html;
        }

        function buildBenchwarmerSection(benchwarmers) {
            let html = '<div class="section"><h2>üí∫ Benchwarmer Analysis</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">Total points scored by players while on the bench (points left on the table each week)</p>';
            html += '<table><thead><tr><th>Rank</th><th>Team</th><th>Total Bench Points</th><th>Avg/Week</th><th>Worst Benching</th></tr></thead><tbody>';
            benchwarmers.all_teams.forEach((team, idx) => {
                const worstDecision = team.worst_benching_decision;
                html += `<tr>
                    <td>${idx + 1}</td>
                    <td>${team.team_name}</td>
                    <td class="negative">${team.total_bench_points.toFixed(1)}</td>
                    <td class="negative">${team.avg_bench_points_per_week.toFixed(1)}</td>
                    <td class="negative">${worstDecision ? `${worstDecision.player_name} (${worstDecision.points.toFixed(1)} pts, Wk ${worstDecision.week})` : '-'}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            return html;
        }

        function buildLuckSection(luck) {
            let html = '<div class="section"><h2>üçÄ Luck Analysis</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">Compares actual record vs expected record based on weekly performance. Positive luck = won more than expected.</p>';
            html += '<table><thead><tr><th>Team</th><th>Actual Record</th><th>Expected Record</th><th>Luck Score</th><th>SOS (Avg Opponent PF)</th></tr></thead><tbody>';

            // Sort by actual wins descending
            const sortedTeams = [...luck.team_reports].sort((a, b) => b.actual_wins - a.actual_wins);

            sortedTeams.forEach(team => {
                const luckClass = team.luck_score > 0 ? 'positive' : 'negative';
                html += `<tr>
                    <td>${team.team_name}</td>
                    <td>${team.actual_record}</td>
                    <td>${team.expected_record}</td>
                    <td class="${luckClass}">${team.luck_score > 0 ? '+' : ''}${team.luck_score.toFixed(1)}</td>
                    <td>${team.strength_of_schedule.avg_opponent_points.toFixed(1)}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            return html;
        }

        function buildFAABSection(faab) {
            let html = '<div class="section"><h2>üí∞ FAAB Analysis</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">FAAB efficiency measured by ROI (points scored per dollar spent). Only counts points when player was in starting lineup.</p>';

            html += '<h3>Team FAAB Rankings</h3><table>';
            html += '<thead><tr><th>Rank</th><th>Team</th><th>Spent</th><th>Remaining</th><th>Total Points</th><th>Avg ROI</th></tr></thead><tbody>';
            faab.owner_rankings.forEach(owner => {
                html += `<tr>
                    <td>${owner.faab_efficiency_rank}</td>
                    <td>${owner.owner_name}</td>
                    <td>$${owner.total_faab_spent}</td>
                    <td>$${owner.faab_remaining}</td>
                    <td>${owner.total_points_from_faab.toFixed(1)}</td>
                    <td>${owner.avg_roi.toFixed(2)}</td>
                </tr>`;
            });
            html += '</tbody></table>';

            // Best pickups
            if (faab.best_value_pickups && faab.best_value_pickups.length > 0) {
                html += '<h3>Best Value FAAB Pickups</h3><table>';
                html += '<thead><tr><th>Player</th><th>Owner</th><th>FAAB</th><th>Points (Started)</th><th>ROI</th></tr></thead><tbody>';
                faab.best_value_pickups.slice(0, 10).forEach(pickup => {
                    html += `<tr>
                        <td>${pickup.player_name} (${pickup.position})</td>
                        <td>${pickup.owner_name}</td>
                        <td>$${pickup.faab_spent}</td>
                        <td>${pickup.points_during_ownership.toFixed(1)}</td>
                        <td class="positive">${pickup.roi.toFixed(2)}</td>
                    </tr>`;
                });
                html += '</tbody></table>';
            }

            html += '</div>';
            return html;
        }

        function buildRosterConstructionSection(rosterConstruction) {
            let html = '<div class="section"><h2>üèóÔ∏è Roster Construction</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">Shows where each team\'s points came from: Draft, Trades, Waivers, or Free Agency. Only counts points when players were in starting lineup during ownership period.</p>';

            html += '<table><thead><tr><th>Team</th><th>Draft %</th><th>Trade %</th><th>Waiver %</th><th>FA %</th><th>Primary Source</th></tr></thead><tbody>';
            rosterConstruction.all_teams.forEach(team => {
                html += `<tr>
                    <td>${team.team_name}</td>
                    <td>${team.breakdown.draft_percentage.toFixed(1)}%</td>
                    <td>${team.breakdown.trade_percentage.toFixed(1)}%</td>
                    <td>${team.breakdown.waiver_percentage.toFixed(1)}%</td>
                    <td>${team.breakdown.free_agent_percentage.toFixed(1)}%</td>
                    <td class="highlight">${team.primary_source}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            return html;
        }

        function buildDraftSection(draft) {
            let html = '<div class="section"><h2>üéØ Draft Analysis</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">Analyzes draft performance vs expected value. Best picks exceeded expectations, worst picks underperformed.</p>';

            // Calculate expected points and best/worst picks
            // Collect all picks
            const allPicks = [];
            draft.team_grades.forEach(team => {
                team.picks.forEach(pick => {
                    allPicks.push({...pick, team_name: team.team_name});
                });
            });

            // Calculate expected points using simple power law: points = 200 / pick^0.5
            allPicks.forEach(pick => {
                pick.expected_points = 200 / Math.pow(pick.pick_number, 0.5);
                pick.value_diff = pick.points_scored - pick.expected_points;
            });

            // Best picks = most above expected
            const sortedByDiff = [...allPicks].sort((a, b) => b.value_diff - a.value_diff);
            const bestPicks = sortedByDiff.slice(0, 5);

            // Worst picks = most below expected (only first 60 picks)
            const earlyPicks = allPicks.filter(p => p.pick_number <= 60);
            const worstPicks = earlyPicks.sort((a, b) => a.value_diff - b.value_diff).slice(0, 5);

            // Calculate without QBs
            const nonQBPicks = allPicks.filter(p => p.position !== 'QB');
            const bestPicksNoQB = [...nonQBPicks].sort((a, b) => b.value_diff - a.value_diff).slice(0, 5);
            const earlyNonQBPicks = nonQBPicks.filter(p => p.pick_number <= 60);
            const worstPicksNoQB = earlyNonQBPicks.sort((a, b) => a.value_diff - b.value_diff).slice(0, 5);

            // QB Toggle
            html += '<div class="toggle-container">';
            html += '<label><input type="checkbox" id="excludeQBs" onchange="toggleQBs()"><span>Exclude QBs from tables</span></label>';
            html += '</div>';

            // Draft chart will be inserted here
            html += '<div id="draftChart" style="width: 100%; height: 500px; margin: 20px 0;"></div>';

            // Best Picks - All positions
            html += '<h3>Top 5 Best Picks (Most Above Expected)</h3><table>';
            html += '<thead><tr><th>Pick #</th><th>Player</th><th>Team</th><th>Actual Points</th><th>Expected Points</th><th>Difference</th></tr></thead>';
            html += '<tbody id="bestPicksAll">';
            bestPicks.forEach(pick => {
                html += `<tr>
                    <td>${pick.pick_number}</td>
                    <td>${pick.player_name} (${pick.position})</td>
                    <td>${pick.team_name}</td>
                    <td class="positive">${pick.points_scored.toFixed(1)}</td>
                    <td>${pick.expected_points.toFixed(1)}</td>
                    <td class="positive">+${pick.value_diff.toFixed(1)}</td>
                </tr>`;
            });
            html += '</tbody>';

            // Best Picks - No QBs
            html += '<tbody id="bestPicksNoQB" style="display: none;">';
            bestPicksNoQB.forEach(pick => {
                html += `<tr>
                    <td>${pick.pick_number}</td>
                    <td>${pick.player_name} (${pick.position})</td>
                    <td>${pick.team_name}</td>
                    <td class="positive">${pick.points_scored.toFixed(1)}</td>
                    <td>${pick.expected_points.toFixed(1)}</td>
                    <td class="positive">+${pick.value_diff.toFixed(1)}</td>
                </tr>`;
            });
            html += '</tbody></table>';

            // Worst Picks - All positions
            html += '<h3>Top 5 Worst Picks (Most Below Expected)</h3><table>';
            html += '<thead><tr><th>Pick #</th><th>Player</th><th>Team</th><th>Actual Points</th><th>Expected Points</th><th>Difference</th></tr></thead>';
            html += '<tbody id="worstPicksAll">';
            worstPicks.forEach(pick => {
                html += `<tr>
                    <td>${pick.pick_number}</td>
                    <td>${pick.player_name} (${pick.position})</td>
                    <td>${pick.team_name}</td>
                    <td class="negative">${pick.points_scored.toFixed(1)}</td>
                    <td>${pick.expected_points.toFixed(1)}</td>
                    <td class="negative">${pick.value_diff.toFixed(1)}</td>
                </tr>`;
            });
            html += '</tbody>';

            // Worst Picks - No QBs
            html += '<tbody id="worstPicksNoQB" style="display: none;">';
            worstPicksNoQB.forEach(pick => {
                html += `<tr>
                    <td>${pick.pick_number}</td>
                    <td>${pick.player_name} (${pick.position})</td>
                    <td>${pick.team_name}</td>
                    <td class="negative">${pick.points_scored.toFixed(1)}</td>
                    <td>${pick.expected_points.toFixed(1)}</td>
                    <td class="negative">${pick.value_diff.toFixed(1)}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';

            // Render draft chart with calculated picks
            setTimeout(() => renderDraftChart(draft, allPicks), 100);

            return html;
        }

        function renderDraftChart(draft, allPicks) {
            if (!draft.team_grades || draft.team_grades.length === 0) return;

            // Extract data from allPicks
            const pickNumbers = allPicks.map(p => p.pick_number);
            const actualPoints = allPicks.map(p => p.points_scored);
            const positions = allPicks.map(p => p.position);
            const playerNames = allPicks.map(p => p.player_name);
            const teamNames = allPicks.map(p => p.team_name);

            // Calculate trend line (polynomial fit approximation)
            const trendX = [];
            const trendY = [];
            for (let i = Math.min(...pickNumbers); i <= Math.max(...pickNumbers); i++) {
                trendX.push(i);
                // Simple power law approximation: points = a / x^b
                trendY.push(200 / Math.pow(i, 0.5));
            }

            // Trend line trace
            const trendTrace = {
                x: trendX,
                y: trendY,
                mode: 'lines',
                name: 'Expected Points',
                line: { color: '#94a3b8', width: 3, dash: 'dash' },
                hoverinfo: 'skip'
            };

            // Scatter trace
            const scatterTrace = {
                x: pickNumbers,
                y: actualPoints,
                mode: 'markers',
                name: 'Actual Points',
                marker: {
                    size: 10,
                    color: actualPoints,
                    colorscale: 'Viridis',
                    showscale: true,
                    colorbar: { title: 'Points' }
                },
                text: playerNames.map((name, i) => `${name} (${positions[i]}) - ${teamNames[i]}`),
                customdata: positions,
                hovertemplate: '%{text}<br>Pick: %{x}<br>Points: %{y:.1f}<extra></extra>'
            };

            const layout = {
                title: 'Draft Pick Value Analysis',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#e0e0e0' },
                xaxis: {
                    title: 'Pick Number',
                    gridcolor: '#374151',
                    gridwidth: 1
                },
                yaxis: {
                    title: 'Points Scored',
                    gridcolor: '#374151',
                    gridwidth: 1
                },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('draftChart', [trendTrace, scatterTrace], layout, {responsive: true});
        }

        function buildTradesSection(trades) {
            let html = '<div class="section"><h2>ü§ù Trade Analysis</h2>';
            html += '<p style="margin-bottom: 15px; color: #94a3b8;">Analyzes trade outcomes based on points scored after the trade.</p>';

            if (trades.most_lopsided_trades && trades.most_lopsided_trades.length > 0) {
                html += '<h3>Most Lopsided Trades</h3><table>';
                html += '<thead><tr><th>Week</th><th>Winner (Players Received)</th><th>Loser (Players Received)</th><th>Point Differential</th></tr></thead><tbody>';
                trades.most_lopsided_trades.slice(0, 10).forEach(trade => {
                    const winnerPlayers = trade.winner === trade.team_a ? trade.team_a_players : trade.team_b_players;
                    const loserPlayers = trade.winner === trade.team_a ? trade.team_b_players : trade.team_a_players;

                    html += `<tr>
                        <td>${trade.week}</td>
                        <td>
                            <strong>${trade.winner}</strong><br>
                            <span style="color: #94a3b8; font-size: 0.85em;">
                                ${winnerPlayers.map(p => `${p.player_name} (${p.position}): ${p.points_after_trade.toFixed(1)} pts`).join('<br>')}
                            </span>
                        </td>
                        <td>
                            <strong>${trade.loser}</strong><br>
                            <span style="color: #94a3b8; font-size: 0.85em;">
                                ${loserPlayers.map(p => `${p.player_name} (${p.position}): ${p.points_after_trade.toFixed(1)} pts`).join('<br>')}
                            </span>
                        </td>
                        <td class="highlight positive">+${trade.point_differential.toFixed(1)}</td>
                    </tr>`;
                });
                html += '</tbody></table>';
            }

            // Transaction Activity
            html += '<h3>Transaction Activity Breakdown</h3>';
            html += '<p style="margin-bottom: 10px; color: #94a3b8;">Shows total moves by type: Trades, Waivers, and Free Agent pickups</p>';
            html += '<table><thead><tr><th>Team</th><th>Trades</th><th>Waivers</th><th>Free Agents</th><th>Total Moves</th></tr></thead><tbody>';

            if (trades.transaction_activity) {
                const sortedActivity = [...trades.transaction_activity].sort((a, b) => b.total_moves - a.total_moves);
                sortedActivity.forEach(team => {
                    html += `<tr>
                        <td>${team.team_name}</td>
                        <td>${team.trade_count}</td>
                        <td>${team.waiver_count}</td>
                        <td>${team.free_agent_count}</td>
                        <td class="highlight">${team.total_moves}</td>
                    </tr>`;
                });
            }
            html += '</tbody></table></div>';

            return html;
        }
    </script>
</body>
</html>
